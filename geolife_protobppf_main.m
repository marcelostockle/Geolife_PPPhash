%%% IMPORTANT NOTE ABOUT ANYTHING IN THIS CODE. WHILE STRUCTURES INVOLVING % S.V ARE INDEX-1, S.V IS INDEX-0.outliers = geolife_preproc_outliers(preP);accepted = 1:numel(outliers);accepted = accepted(outliers);% Extra pre-processing. Sequences are condensed to either 1) denote movement% from one quadrant to another EXCLUSIVELY or 2) denote quadrant position at% fixed time intervals. Choose the prefer modality by setting fixed_time_conf.% This process will create the S.cseq field (condensed sequence).fixed_time_conf = false;% units: Secondsfixed_time = 120.0 ; % transforms the input value to DAYS unitsfixed_time = fixed_time / (24 * 60 * 60); for (i = accepted)  if (fixed_time_conf)    len = numel(S(i).seq);    ind = zeros(1, len);    timest = S(i).traj(1,1);    ind(1) = 1;    for (j = 2:len)      if (S(i).traj(j,1) > timest + fixed_time)        ind(j) = 1;        timest = S(i).traj(j,1);      endif    endfor    ind = find(ind);    S(i).cseq = S(i).seq(ind);  else      ind = cat(1, 1, diff(S(i).seq));    ind = find(ind != 0);    S(i).cseq = S(i).seq(ind);  endifendforperiod = 5;min_count = 30;[S, C, F] = geolife_protobppf_results(S, preP, period, min_count);% decompress hashN = (numel(preP.partX)+1) * (numel(preP.partY)+1);dim = period * floor(period / 2);aux = 1:dim;v_ind = [mod(aux - 1, period); mod(aux - 1 + ceil(aux/period), period)];for (order = 2:period)  F{order - 1}.patterns = -1 * ones(numel(F{order - 1}.keys), period);  for (i = 1:numel(F{order - 1}.keys))    for (j = 1:(order - 1))      ind = v_ind(:, F{order - 1}.PPPpoint(i, j)) + 1;      % this next operations are only possible when PPPhash is maintained      % as Index-0      h = F{order - 1}.PPPhash(i, j);      h = [floor(h / N); mod(h, N)];      F{order - 1}.patterns(i, ind) = h;    endfor  endforendforfor (i = 1:numel(F))  for (j = 1:numel(F{i}.keys))    [size(F{i}.keys{j}, 1) F{i}.patterns(j,:)]  endfor
endfor